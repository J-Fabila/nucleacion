					20 de febrero del 2025
El objetivo es acoplarlo con mace y por lo tanto con nuestro potencial de MACE.
Análisis de archivos:
 * L1001.xyz :: parece ser la configuración inicial
 * ip_definition.dat :: parecen ser los parámetros de lammps por los pair_coeff
 * conf.data :: es el config file
 * inc_lib.xyz :: ¿Quizás sean las partículas con las que hace nucleación?
 * lammps_io.py :: clase lammps MD, input generator, corre colisiones
 * main.py :: Bueno, ¿que mas puede ser?
 * Nucleator.sub :: es el escript para lanzar el cálculo
 * particle.py :: clase particula heredada de ASE
 * runconfig.py :: configuration of the run
					11 de julio del 2025
Notas de Álex:
* Conf.data: In cond.data we specify all the necessary input for the nucleation growth to start. Like the cycles, temperature, desired stiochiometry. How many elements and their charges and if there are shells included. 
* Inc_lib.xyz: Here we specify the species that are going to be generated in every step. The process is number of atoms followed by charge and the probability and then xyz coordinates of the species. 
* Ip_definition: This file is where the potential is specified.
* L1001.xyz: This file is the seed particle. The first step. You specify the number of atoms, overall charge and the coordinates. 
* lammps_io.py: This is the main wrapper of the lammps and that you should probably change it to work with ASE. it creates the input in everycycle and automates the process for the outputs. 
* main.py: Tha main program that calls all the functions. 
* Nucleator.sub, Job sender, particle.py, runconfig.py and utilities.py: The utility functions of the code. 

Puntos que se pueden mejorar:
* el conf.data tiene un formato de texto poco robusto, se podría cambiar por un yaml
* la función que lee parámetros se podría cambiar simplemente por un yaml.load, tambien toda la estructura de parametros se puede cambiar en función de eso
* reorganizar el repo, es un poco caótico
* añadir variable de selección de calculadora

					1 de agosto del 2025
* lammps_io es una clase fabricada, no un paquete (importante)
* lammps_MD es un wrapper, no una función nativa de lammps
* lammps_io :: Lammps_MD :: run_collision
* Lammps_MD :: init :: run_command puede variar de sistema a sistema
  sería conveniente hacerlo general
* Lammps_MD :: init
               run_collision :: se llama así pero 
               read_final_structure
               clean_md
               
* Considero que hay 2 opciones: refactorizar el código y después
  integrar MACE o directamente cargarnos la parte lammps y hacerlo
  con MACE y ya si eso, después integrarlo todo
* ip definition tiene los parametros del campo de fuerzas de lammps


Lista de cambios: 
* Input conf.data -> conf.yaml : robust and flexible standard format that allows comments and more
  runconfig lee linea por linea en orden especifico
* naggs.py ahora es el principal
* En principio es posible usar LAMMPS directamente sin escribir en disco los archivos de entrada/salida
* Archivos que se quedan:
  particle.py
  incoming_part_library.py # esta dentro de particle, pero tendria que estar en su archivo aparte
  utilities.py: se cambia a utils, hay que tener cuidado porque parece que está alambrado a SiO
                solo contiene get_model_system(particle,incoming_particle)
  o sea que bien podríamos meter todo ésto en utils.py
* Podríamos añadir un logger guapo, aunque por pura estética, no sé hasta que punto haga falta
* lammps_io se tendria que reescribir pero yo ahora mismo la dejaría como está y nos podemos
  concentrar en MACE, ya si eso, después añadimos lammps también
* lammps_io esta hardcodeada a un comando de run_command específico de la máquina
* Añadiría más parámetros en conf.yaml para poner los de lammps aunque no los usemos ahora
  y los nuevos de MACE
* Me falta por entender que es el inc_lib
* Usar MACE únicamente como calculadora, tendríamos que cambiar la estructura del run_collision

* Yo reorganizaría:
  conf.yaml
  naggs.py
  src
     calculators
        LAMMPS
           inputs
           wrappers_lammps 
        MACE
     utils.py
     particle.py   
     otros.py
					3 de agosto del 2025
* model system es una instancia de la clase atoms, desde ahi ya se
  puede hacer el wrapper para MACE.
* naggs originalmente utiliza NVE
* naggs originalmente utiliza un número fijo de pasos de relajación
* Empiezan las pruebas de verdad, usa TiC en los inputs.
* Puede que check connectivity no funcione si no tenemos la partícula
  inicializada desde los parámetros de LAMMPS, habrá que verificar
* Podríamos buscar hacer las funciones esas que sugieren los comentarios
  para mejorar la legibilidad porque es verdad que es un desmadre
* Podrías ir pensando en cambiar el logger
* Cuantos menos archivos de entrada se necesiten es mejor, podriamos eliminar
  el inc library y simplemente añadir esas variables en el conf.yaml
* La parte de added is true es para acumular la particula obtenida al ciclo,
  sino es que la descarta
* Podríamos preguntarle a Andreu sobre el inc_lib para saber si vale la pena
  cambiar el formato al conf.yaml
* Tambien podríamos preguntarle sobre las otras variables del conf.dat, como
  presion o densidad y tambien lo de los shells
					4 de agosto del 2025
* Parece que el número de átomos de la configuración puede ser diferente del
  número deseado de estequiometria: el check connectivity tendría además que
  verificar que no se hayan perdido átomos
* el runconfig devuelve elements :: element_conv :: {'O': [1, 4], 'Si': [2], 'Mg': [3]}
  importante saberlo para la integracion
* el charges es: {1: 1.91981, 4: -3.28111, 2: 2.7226, 3: 1.3613}
* SHELLS ['O']

* Ahora todos los inputs son correctos y funcionan para ambos, tendríamos
  que compatibilizar el charges con elements y elements_conv
					5 de agosto del 2025
* check connectivity no parece funcionar bien, más fácil: matriz de distancias,
  si al menos uno está conectado para cada uno bien.
* Podemos añadir el connectivity check cada 100 pasos por ejemplo o algo que vea
  que las distancias maximas no sean kilometricas, si es asi que descarte la
  geometría en el MACE directamente
* Ya intentamos adaptar el código este al MACE, pero me sale más barato hacernos
  uno nuevo desde 0.
					6 de agosto del 2025
* Parece que algunos átomos los genera muy lejos o sin mucha potencia
  tendríamos que aislar la función de generador de fragmentos y analizarla mejor
* También deberías añadir la funcionalidad de que puedas generar
  fragmentos de verdad, no solo átomos sueltos
* src/GenerateFragment, habría que quitar el inicial, deseado, disponible
  cuando terminemos las pruebas
* Añadir la variable fragment_file, if None, genera átomos sueltos
* Generar velocidades con Maxwell y generar rotacion random
* El GenerateFragment debe ser consciente de una u otra situación

					9 de agosto del 2025
* Se podrían definir diferentes termostatos para colisión y relajación
* De hecho, creo que en el original lo hacen así, verifica
* Habría que trabajar en los loggs
* Mira la posibilidad de añadir un working dir que guarde las xyz alli
* Los átomos se frenan casi de inmediato debido al termostato, cuando
  uses Verlet el factor x10 en la temperatura va a hacerse presente
* Definición del primer lote de experimentos:
   * Exp 1: TiC -> Ti13C14 : Verlet : Radial : dist_from_seed 5
   * Exp 2: TiC -> Ti13C14 : Verlet : Angular : dist_from_seed 5
   * Exp 3: TiC -> Ti13C14 : Langevin : Radial : dist_from_seed 5
   * Exp 4: TiC -> Ti13C14 : Langevin : Angular : dist_from_seed 5
* Segundo lote de experimentos:
   * Exp 5 TiC -> Ti13C14 : Verlet : None : dist_from_seed 1
   * Exp 6 TiC -> Ti13C14 : Verlet : Radial : dist_from_seed 1
   * Exp 7 TiC -> Ti13C14 : Langevine : None : dist_from_seed 1
   * Exp 8 TiC -> Ti13C14 : Langevine : Radial : dist_from_seed 1

   * Exp 5: Ti13C14 -> Ti63C62 : Por def : Radial
   * Exp 6: Ti13C14 -> Ti63C62 : Por def : Angular

* Resultados de los experimentos:
   * Exp 1: No progresa, se queda en 4 o 5 átomos, algunos átomos
            libres volando por ahi, se ve que ha  fallado la cosa
            que  verifica que estén  todos los átomos  conectados
   * Exp 2: Idem
   * Exp 3: Idem
   * Exp 4: Esencialmente lo mismo

   * Exp 5: Idem
   * Exp 6: Idem
   * Exp 7: Parece funcionar mejor

					13 de agosto del 2025
* Error cuando termina de ejecutarse:
Traceback (most recent call last):
  File "/home/yuca/workdir/naggs/naggs.py", line 35, in <module>
    fragment = GenerateFragment(current_stoichiometry,config, rho)
  File "/home/yuca/workdir/naggs/src/GenerateFragment.py", line 71, in GenerateFragment
    return particula
UnboundLocalError: local variable 'particula' referenced before assignment

					14 de agosto del 2025

* Cambié la distancia de la partícula de rho + dist a rho/2+dist. Sino queda muy lejos
* Parece ser que la verificación de estructuras no funciona del todo bien, habría que
  aislarla y probarla por separado

					19 de agosto del 2025
* La verificación de estructuras funciona bien, era la relajación
  lo que fallaba.
* Sigo pensando que como está planteado la relajación es redundante
* Se podría cambiar la MD por relajación de verdad como opción
* Dejo listo el experimento 11, identico al 10 pero partiendo de un
  checkpoint.xyz que tiene ya buen tamaño
* Habrá falta afinar la parte de las colisiones, quizas dejar por
  pocos fs la trayectoria original en linea recta (NVE) y luego
  cambiar a NVT
* Por el momento, lo de las configuraciones que se rompen y se pierde
  el proceso parece ya estar resuelto, era el problema de las
  relajaciones
* el codigo se vuelve muy lento cuando la NP explota, podríamos
  añadir el checkcontinuity cada tanto o un break si las distancias
  van demasiado lejos
* Parece que si la relajacion falla, continua al siguiente estep
  y por eso no imprime la señal de i,estequiometria,etc,aceptado
* Podemos probar a darle pocos  fs de NVE en colision  y relajar
  el resto del tiempo
* En el runcolission lo mismo que pusiste en el relaxation

					20 de agosto del 2025
* exp 13 es identico al 12, desde TiC hasta Ti50C50 pero analizando
  distancia = 5 y off radial
* exp 14 es identico al 13, desde TiC hasta Ti50C50 pero analizando
  distancia = 5 y off angular

* Cosas que aún faltan:
  * implementación LAMMPS
  * verificar que funciona con la versión más moderna de MACE
  * quizás los LOGS

* Experimentos de verdad
  * conf_1.yaml :: TiC -> Ti14C13
  * conf_2.yaml :: TiC -> Ti18C14
  * conf_3.yaml :: TiC -> Ti18C18
  * conf_4.yaml :: TiC -> Ti24C20
  * conf_5.yaml :: TiC -> Ti24C24
  * conf_6.yaml :: TiC -> Ti32C28
  * conf_7.yaml :: TiC -> Ti32C32
  * conf_8.yaml :: TiC -> Ti40C36
  * conf_9.yaml :: TiC -> Ti40C40
  * conf_10.yaml :: TiC -> Ti50C46
  * conf_11.yaml :: TiC -> Ti50C50
  * conf_12.yaml :: TiC -> Ti63C58
  * conf_13.yaml :: TiC -> Ti63C62

  * conf_14.yaml :: Ti13C14 -> Ti18C14
  * conf_15.yaml :: Ti13C14 -> Ti18C18
  * conf_16.yaml :: Ti13C14 -> Ti24C20
  * conf_17.yaml :: Ti13C14 -> Ti24C24
  * conf_18.yaml :: Ti13C14 -> Ti32C28
  * conf_19.yaml :: Ti13C14 -> Ti32C32
  * conf_20.yaml :: Ti13C14 -> Ti40C36
  * conf_21.yaml :: Ti13C14 -> Ti40C40
  * conf_22.yaml :: Ti13C14 -> Ti50C46
  * conf_23.yaml :: Ti13C14 -> Ti50C50
  * conf_24.yaml :: Ti13C14 -> Ti63C58
  * conf_25.yaml :: Ti13C14 -> Ti63C62

					21 de agosto del 2025
* Experimento 14 va mucho mejor que el 13, pero aún así no va óptimo,
  pero va bien: la diferencia es que lleva offset angular y 5 angs
  desde la superficie. Experimento 13 lleva 5 A tambien pero radial
